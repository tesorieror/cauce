-- Important NOTE!
-- Events starting in uppercase are avoided, because they are considered part of a hierarchy of them
module AnalysisToTransformationModule; -- Module Template

create 	RSModel : RSMetamodel, IFModel : IFMetamodel, ECModel:ECMetamodel 
		from 
		SoModel : SoMetamodel, TaModel: TaMetamodel, SpModel: SpMetamodel;

--uses SocialModelLibrary;
--uses RegularExpressions;
--uses TaskModelLibrary;
--uses SpaceModelLibrary;

helper def: rsCounter : Integer = 1;

helper def: ifCounter : Integer = 1;

helper def: ecCounter : Integer = 1;

--helper def: evCounter : Integer = 1;

--helper def: roleFromName(n : String) : SoMetamodel!Role = SoMetamodel!Role.allInstances()->any(r | r.name = n);


-- Imperative version   

entrypoint rule Main(){   
	using{
	}
	do{
		'Working...Done'->toString()->println();		
	}
}	

rule SocietyToSystem{	
	from 
			society : SoMetamodel!Society
	to
			systemRS : RSMetamodel!SystemInformationFlowReferenceSpace
			(name <- society.name),
			rootRS : RSMetamodel!ReferentialSpace
			(name<-society.name+'Space', system<-society),
			systemIF : IFMetamodel!SystemInformaitonFlow
			(name <- society.name),
			systemEC : ECMetamodel!SystemContext
			(name <- society.name)
	do{		
		systemRS.id <- thisModule.rsCounter;
		thisModule.rsCounter <- thisModule.rsCounter + 1;
		rootRS.id <- thisModule.rsCounter;
		thisModule.rsCounter <- thisModule.rsCounter + 1;
		systemIF.id <- thisModule.ifCounter;
		thisModule.ifCounter <- thisModule.ifCounter + 1;
--TODO
--		Change ECMM to support id	
--		systemEC.id <- thisModule.ecCounter;
--		thisModule.ecCounter <- thisModule.ecCounter + 1;	
	}
}

rule RoleToEntity{	
	from 
			role : SoMetamodel!Role (role.children.size()=0)
	to
			--RSMM
			entityReference : RSMetamodel!ContextAwareEntityReference
			(name <- role.name, system<-role.society, entity<- role.name),
			incomingReferenceDependency: RSMetamodel!SpaceToEntityReferenceDependency
			(system <- role.society, child<-role, parent <- thisModule.resolveTemp(role.society, 'rootRS'), cardinality<-999),
			--IFMM
			entity : IFMetamodel!ContextAwareEntity
			(name <- role.name, system<-thisModule.resolveTemp(role.society, 'systemIF')),
			--ECMM
			entityContext : ECMetamodel!EntityContext
			(entity <- role.name, system<-thisModule.resolveTemp(role.society, 'systemEC')),
			----Memories
			roleMemory: ECMetamodel!HolderMemory			
			(name <- role.name+'.role', entityContext<-thisModule.resolveTemp(role, 'entityContext')),
			initMemory: ECMetamodel!TimeMemory
			(name <- role.name+'.init', entityContext<-thisModule.resolveTemp(role, 'entityContext')),
			----Init Situation
			initSituation:ECMetamodel!ContextSituation
			(name<-'init-'+role.name, entityContext<-thisModule.resolveTemp(role, 'entityContext')),
			------Init condition
			initCondition:ECMetamodel!MemoryContextCondition
			(expression <- 'off', situation<-thisModule.resolveTemp(role, 'initSituation'), contextMemory<-initMemory),
			------Init actions
			initAction: ECMetamodel!ContextAction
			(expression <- '(on,0)', situation<-thisModule.resolveTemp(role, 'initSituation'), memory<-initMemory),
			initRoleAction: ECMetamodel!ContextAction
			(expression <- role.name, situation<-thisModule.resolveTemp(role, 'initSituation'), memory<-roleMemory)--,
			----Variable definitions
--			roleVariableDefinition: ECMetamodel!VariableDataDefinition
--			(name <- 'Role', entityContext<-thisModule.resolveTemp(role, 'entityContext'), definition<-role->getRoleVaraibleDefinition())--,			
	do{		
		--RSMM
		entityReference.id <- thisModule.rsCounter;
		thisModule.rsCounter <- thisModule.rsCounter + 1;
		incomingReferenceDependency.id <- thisModule.rsCounter;
		thisModule.rsCounter <- thisModule.rsCounter + 1;
		--IFMM
		entity.id <- thisModule.ifCounter;
		thisModule.ifCounter <- thisModule.ifCounter + 1;
		--ECMM
		entityContext.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		----Memories
		initMemory.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;		
		roleMemory.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;		
		----Situations
		initSituation.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;		
		----Conditions
		initCondition.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		----Actions
		initAction.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		initRoleAction.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		----Varaible definition
--		roleVariableDefinition.id <- thisModule.ecCounter;
--		thisModule.ecCounter <- thisModule.ecCounter + 1;		
	}
}


rule TaskToSituation{	
	from 
		simpleTask : TaMetamodel!SimpleTask(simpleTask->getInvolvedEntities()->size()=1)
	to
		--ECMM
		----Situations
		situationTaskAlone: ECMetamodel!ContextSituation
		(name<-simpleTask.name, entityContext<-thisModule.resolveTemp(simpleTask->getEntity(), 'entityContext')),
		----Conditions
		memoryContextTaskAlone: ECMetamodel!MemoryContextCondition
		(situation<-situationTaskAlone
			, expression<-simpleTask->getRoles()->any(x|true).name
			, contextMemory<-thisModule.resolveTemp(simpleTask->getInvolvedEntities()->any(x|true), 'roleMemory')
		)		
	do{
		--ECMM
		situationTaskAlone.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		memoryContextTaskAlone.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		
	}
}

rule TaskToPointToPointInformationFlows{	
	from 
		simpleTask : TaMetamodel!SimpleTask
		(simpleTask->isPointToPointInformationFlow())
	to
--IFMM
		pointToPointInformationFlow: IFMetamodel!PointToPointInformationFlow
		(name<-simpleTask.name, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemIF')
			, outputData<-outputVariables
			, inputData<-inputVariables),
		entityToPointToPoint: IFMetamodel!EntityToPointToPointInformationFlowEdge
		(source<-thisModule.resolveTemp(simpleTask->getInformationFlow().source, 'entity') 
			, target<-pointToPointInformationFlow
			, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemIF')
		), 
		pointToPointToEntity: IFMetamodel!PointToPointInformationFlowToEntityEdge			
		(source<-pointToPointInformationFlow
			, target<-thisModule.resolveTemp(simpleTask->getInformationFlow().target, 'entity') 
			, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemIF')
		),
		--Output Variables
		outputVariables: distinct IFMetamodel!OutputData
		foreach(oData in simpleTask->getOutputVaraibles())
			(definition<-oData),
		--Input Variables
		inputVariables: distinct IFMetamodel!InputData
		foreach(iData in simpleTask->getInputVaraibles())
			(definition<-iData),	
		--ECMM			
		situationP2PTask: ECMetamodel!ContextSituation
		(name<-simpleTask.name+'Event'		
		, entityContext<-thisModule.resolveTemp(simpleTask->getInformationFlow().target, 'entityContext')),
		
		conditionP2PTaskSource: ECMetamodel!MemoryContextCondition
		(situation<-situationP2PTask,
			expression<-simpleTask->getInformationFlow().source.name,
			contextMemory<-thisModule.resolveTemp(simpleTask->getInformationFlow().source, 'roleMemory')),
			
		conditionP2PTaskTarget: ECMetamodel!MemoryContextCondition
		(situation<-situationP2PTask,
			expression<-simpleTask->getInformationFlow().target.name,
			contextMemory<-thisModule.resolveTemp(simpleTask->getInformationFlow().target, 'roleMemory')),

		sensingP2PTask: ECMetamodel!SensingContextCondition
		(situation<-situationP2PTask,
			informationflow<-simpleTask.name)
			
	do{
		--IFMM
		pointToPointInformationFlow.id <- thisModule.ifCounter;
		thisModule.ifCounter <- thisModule.ifCounter + 1;
		--ECMM
		situationP2PTask.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;		
		conditionP2PTaskSource.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;		
		conditionP2PTaskTarget.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;			
		sensingP2PTask.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;			
	}
}

rule TaskToBroadcastInformationFlows{	
	from 
		simpleTask : TaMetamodel!SimpleTask
		(simpleTask->isBroadcastInformationFlow())
	to
		--IFMM
		broadcastInformationFlow: IFMetamodel!BroadcastInformationFlow
		(name<-simpleTask.name, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemIF')
			, data<-outputVariables),
		entityToBroadcast: IFMetamodel!EntityToBroadcastInformationFlowEdge
		(source<-thisModule->resolveTemp(simpleTask->getInformationFlow().source, 'entity')		
			, target<-broadcastInformationFlow
			, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemIF')
		), 
		broadcastToEntity: IFMetamodel!BroadcastInformationFlowToEntityEdge			
		(source<-broadcastInformationFlow 
		, target<-thisModule->resolveTemp(simpleTask->getInformationFlow().target, 'entity')		
		, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemIF')
		),
		--Output Variables
		outputVariables: distinct IFMetamodel!OutputData
		foreach(oData in simpleTask->getOutputVaraibles())
			(definition<-oData),
		--ECMM			
		situationBroadcastTask: ECMetamodel!ContextSituation
		(name<-simpleTask.name+'Event'
		, entityContext<-thisModule.resolveTemp(simpleTask->getInformationFlow().target, 'entityContext')),

		conditionBroadcastTaskSource: ECMetamodel!MemoryContextCondition
		(situation<-situationBroadcastTask,
			expression<-simpleTask->getInformationFlow().source.name,
			contextMemory<-thisModule.resolveTemp(simpleTask->getInformationFlow().source, 'roleMemory')),
			
		conditionBroadcastTaskTarget: ECMetamodel!MemoryContextCondition
		(situation<-situationBroadcastTask,
			expression<-simpleTask->getInformationFlow().target.name,
			contextMemory<-thisModule.resolveTemp(simpleTask->getInformationFlow().target, 'roleMemory')),

		sensingBroadcastTask: ECMetamodel!SensingContextCondition
		(situation<-situationBroadcastTask,
			informationflow<-simpleTask.name)		
		
	do{
		--IFMM
		broadcastInformationFlow.id <- thisModule.ifCounter;
		thisModule.ifCounter <- thisModule.ifCounter + 1;
		--ECMM
		situationBroadcastTask.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		conditionBroadcastTaskSource.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;		
		conditionBroadcastTaskTarget.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;			
		sensingBroadcastTask.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;			
	}
}

rule SpaceToEntity{	
	from 
		space : SpMetamodel!Space
		(space->isEntity() and space.generalizedBy->forAll(g| g.parent->isEntity()) and (space.generalizedBy->size()>0))
	to
		--IFMM
		spaceEntity: IFMetamodel!ContextAwareEntity
		(name <- space.name, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemIF')),
		--ECMM
		spaceEntityContext: ECMetamodel!EntityContext
		(entity<- space.name, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemEC')),
		----Memories
		spaceRoleMemory: ECMetamodel!HolderMemory			
		(name <- space.name+'.role', entityContext<-spaceEntityContext),
		spaceInitMemory: ECMetamodel!TimeMemory
		(name <- space.name+'.init', entityContext<-spaceEntityContext),
		----Init Situation
		spaceInitSituation: ECMetamodel!ContextSituation
		(name<-'init-'+space.name, entityContext<-spaceEntityContext),
		------Init condition
		spaceInitCondition: ECMetamodel!MemoryContextCondition
		(expression <- 'off', situation<-spaceInitSituation, contextMemory<-spaceInitMemory),
		------Init actions
		spaceInitAction: ECMetamodel!ContextAction
		(expression <- '(on,0)', situation<-spaceInitSituation, memory<-spaceInitMemory),
		spaceInitRoleAction: ECMetamodel!ContextAction
		(expression <- space.name, situation<-spaceInitSituation, memory<-spaceRoleMemory),
		
		--RSMM
		entityReferenceFromSpace: RSMetamodel!ContextAwareEntityReference
		(name <- space.name, entity<-space.name, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemRS')),
		
		entityReferenceDependencyFromSpace: RSMetamodel!SpaceToEntityReferenceDependency
		(child<-entityReferenceFromSpace
			, cardinality<-999
			, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemRS')
			, parent<-thisModule.resolveTemp(thisModule->getSociety(), 'rootRS'))
		
	do{
		--IFMM
		spaceEntity.id <- thisModule.ifCounter;
		thisModule.ifCounter <- thisModule.ifCounter + 1;
		
		--ECMM
		spaceEntityContext.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;	
		spaceRoleMemory.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;		
		spaceInitMemory.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;		
		spaceInitSituation.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		spaceInitCondition.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;		
		spaceInitAction.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;		
		spaceInitRoleAction.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;		
		
		--RSMM
		entityReferenceFromSpace.id <- thisModule.rsCounter;
		thisModule.rsCounter <- thisModule.rsCounter + 1;		
		entityReferenceDependencyFromSpace.id <- thisModule.rsCounter;
		thisModule.rsCounter <- thisModule.rsCounter + 1;		
	}
}


rule SpaceToEntityHierarchy{	
	from 
		space : SpMetamodel!Space
		(space->isEntity() and space.generalizedBy->forAll(g| not g.parent->isEntity()))
	to
		--IFMM
		spaceEntityHierarchy: IFMetamodel!ContextAwareEntity
		(name <- space.name, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemIF')),
		
		spacePointToPointInformationFlows: distinct IFMetamodel!PointToPointInformationFlow
		foreach(iFlow in space->getSpaceInformationFlows())
		(name<-space.name+'2'+iFlow.entity+'Event'
			, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemIF')
			, outputData<-spaceOutputVariablesHierarchy
--			, inputData<-inputVariables
		),
		entityToPointToPointHierarchy: distinct IFMetamodel!EntityToPointToPointInformationFlowEdge
		foreach(iFlow in space->getSpaceInformationFlows())
		(source<-spaceEntityHierarchy
			,target<-spacePointToPointInformationFlows
			,system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemIF')
		), 
		pointToPointToEntityHierarchy: distinct IFMetamodel!PointToPointInformationFlowToEntityEdge
		foreach(iFlow in space->getSpaceInformationFlows())
		(source<-spacePointToPointInformationFlows
			, target<-thisModule.resolveTemp(iFlow.entity->toRole(), 'entity') 
			, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemIF')
		),
		spaceOutputVariablesHierarchy: distinct IFMetamodel!OutputData
		foreach(oData in space->getOutputData())		
			(definition<-oData),
			
		--ECMM
		spaceEntityContextHierarchy: ECMetamodel!EntityContext
		(entity<-space.name
			, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemEC')
		),
		----Memories
		spaceRoleMemoryHierarchy: ECMetamodel!HolderMemory			
		(name <- space.name+'.role', entityContext<-spaceEntityContextHierarchy),
		spaceInitMemoryHierarchy: ECMetamodel!TimeMemory
		(name <- space.name+'.init', entityContext<-spaceEntityContextHierarchy),
		----Init Situation
		spaceInitSituationHierarchy: ECMetamodel!ContextSituation
		(name<-'init-'+space.name, entityContext<-spaceEntityContextHierarchy),
		------Init condition
		spaceInitConditionHierarchy:ECMetamodel!MemoryContextCondition
		(expression <- 'off', situation<-spaceInitSituationHierarchy, contextMemory<-spaceInitMemoryHierarchy),
		------Init actions
		spaceInitActionHierarchy: ECMetamodel!ContextAction
		(expression <- '(on,0)', situation<-spaceInitSituationHierarchy, memory<-spaceInitMemoryHierarchy),
		initRoleActionHierarchy: ECMetamodel!ContextAction
		(expression <- space.name, situation<-spaceInitSituationHierarchy, memory<-spaceRoleMemoryHierarchy),
		
		----Events		
		spaceEventSituationHierarchy: distinct ECMetamodel!ContextSituation
		foreach(iFlow in space->getSpaceInformationFlows())
		(name<-space.name+'Event' 
			, entityContext<-thisModule.resolveTemp(iFlow.entity->toRole(), 'entityContext')
		),
		
		conditionEventSourceHierarchy: distinct ECMetamodel!MemoryContextCondition
		foreach(iFlow in space->getSpaceInformationFlows())
		(situation<-spaceEventSituationHierarchy->any(x|x.name=space.name+'Event' and x.entityContext.entity=iFlow.entity),
			expression<-space.name,
			contextMemory<-spaceRoleMemoryHierarchy),

		conditionEventTargetHierarchy: distinct ECMetamodel!MemoryContextCondition
		foreach(iFlow in space->getSpaceInformationFlows())
		(situation<-spaceEventSituationHierarchy->any(x|x.name=space.name+'Event'  and x.entityContext.entity=iFlow.entity),
			expression<-iFlow.entity,
			contextMemory<-spaceRoleMemoryHierarchy),			

		sensingEventHierarchy: distinct ECMetamodel!SensingContextCondition
		foreach(iFlow in space->getSpaceInformationFlows())
		(situation<-spaceEventSituationHierarchy->any(x|x.name=space.name+'Event'  and x.entityContext.entity=iFlow.entity),
			informationflow<-space.name+'Event'),		
		
			
		--RSMM
		entityReferenceFromSpaceHierarchy: RSMetamodel!ContextAwareEntityReference
		(name <- space.name, entity<-space.name, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemRS')),
		
		entityReferenceDependencyFromSpaceHierarchy: RSMetamodel!SpaceToEntityReferenceDependency
		(child<-entityReferenceFromSpaceHierarchy
			, cardinality<-999
			, system<-thisModule.resolveTemp(thisModule->getSociety(), 'systemRS')
			, parent<-thisModule.resolveTemp(thisModule->getSociety(), 'rootRS'))
			
		
	do{
		--IFMM
		spaceEntityHierarchy.id <- thisModule.ifCounter;
		thisModule.ifCounter <- thisModule.ifCounter + 1;
		
		for(p2pif in spacePointToPointInformationFlows){
			p2pif.id <- thisModule.ifCounter;
			thisModule.ifCounter <- thisModule.ifCounter + 1;
		}
		--ECMM
		spaceEntityContextHierarchy.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		
		spaceRoleMemoryHierarchy.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		
		spaceInitMemoryHierarchy.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		
		spaceInitSituationHierarchy.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		
		spaceInitConditionHierarchy.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		
		spaceInitActionHierarchy.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		
		initRoleActionHierarchy.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		---- Events
		for(e in spaceEventSituationHierarchy){
			e.id <- thisModule.ecCounter;		
			thisModule.ecCounter <- thisModule.ecCounter + 1;
		}
		
		for(e in conditionEventSourceHierarchy){
			e.id <- thisModule.ecCounter;		
			thisModule.ecCounter <- thisModule.ecCounter + 1;
		}
		
		for(e in conditionEventTargetHierarchy){
			e.id <- thisModule.ecCounter;		
			thisModule.ecCounter <- thisModule.ecCounter + 1;
		}
		
		for(e in conditionEventSourceHierarchy){
			e.id <- thisModule.ecCounter;		
			thisModule.ecCounter <- thisModule.ecCounter + 1;
		}
		
		--RSMM
		entityReferenceFromSpaceHierarchy.id <- thisModule.rsCounter;
		thisModule.rsCounter <- thisModule.rsCounter + 1;		
		entityReferenceDependencyFromSpaceHierarchy.id <- thisModule.rsCounter;
		thisModule.rsCounter <- thisModule.rsCounter + 1;	
	}
}

rule SpaceGeneralizationToInformationFlow{
	from 
		spaceGeneralization: SpMetamodel!Generalization
		(spaceGeneralization.generalizes->isEntity() and spaceGeneralization.parent->isEntity())
	to
		--IFMM
		spaceInformationFlow:IFMetamodel!PointToPointInformationFlow
		(name<- spaceGeneralization.generalizes.name+'-'+spaceGeneralization.parent.name 
			, system<-thisModule->getSystemInformationFlow()
			, outputData<-spaceOutputVariables
		),

		spaceEntityToPointToPoint: IFMetamodel!EntityToPointToPointInformationFlowEdge
		(source<-spaceGeneralization.generalizes
			, target<-spaceInformationFlow
			, system<-thisModule->getSystemInformationFlow()
		), 
		spacePointToPointToEntity: IFMetamodel!PointToPointInformationFlowToEntityEdge			
		(source<-spaceInformationFlow
			, target<-spaceGeneralization.parent 
			, system<-thisModule->getSystemInformationFlow()
		),
		spaceOutputVariables: distinct IFMetamodel!OutputData
		foreach(oData in spaceGeneralization->getOutputData())
			(definition<-oData),
			
		--ECMM	
		----Events		
		generalizationEventSituation: ECMetamodel!ContextSituation
		(name<-spaceGeneralization.generalizes.name+'Event' 
			, entityContext<-thisModule.resolveTemp(spaceGeneralization.parent, 'spaceEntityContextHierarchy')
		),
		generalizationEventSource: ECMetamodel!MemoryContextCondition
		(situation<-generalizationEventSituation,
			expression<-spaceGeneralization.generalizes.name,
			contextMemory<-thisModule.resolveTemp(spaceGeneralization.generalizes, 'spaceRoleMemory')),
			
		generalizationEventTarget: ECMetamodel!MemoryContextCondition
		(situation<-generalizationEventSituation,
			expression<-spaceGeneralization.parent.name,
			contextMemory<-thisModule.resolveTemp(spaceGeneralization.parent, 'spaceRoleMemoryHierarchy')),
			
		generalizationSensingEvent: ECMetamodel!SensingContextCondition
		(situation<-generalizationEventSituation,
			informationflow<-spaceGeneralization.generalizes.name+'-'+spaceGeneralization.parent.name)		
		
	do{
		--IFMM
		spaceInformationFlow.id <- thisModule.ifCounter;
		thisModule.ifCounter <- thisModule.ifCounter + 1;	

--		TODO ADD		
--		spaceEntityToPointToPoint.id <- thisModule.ifCounter;
--		thisModule.ifCounter <- thisModule.ifCounter + 1;	
		
--		spacePointToPointToEntity.id <- thisModule.ifCounter;
--		thisModule.ifCounter <- thisModule.ifCounter + 1;	
		--ECMM

		generalizationEventSituation.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		
		generalizationEventSource.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		
		generalizationEventTarget.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;
		
		generalizationSensingEvent.id <- thisModule.ecCounter;
		thisModule.ecCounter <- thisModule.ecCounter + 1;		
		
	}			
}


helper context SpMetamodel!Space def: getOutputData():Set(String)=
	self->getSpaceInformationFlows()->collect(ev|
		let od:String= ev.event->split('[+]')
			->select(s | s->isAbstractEvent()) 
				->iterate(s; answer:String=''| s + '+' + answer)
		in
			if(od->size()>0) then od->substring(1, od->size()-1) 
			else ev.event endif
	);

 
--	let events:Set(String)=	self->getSpaceInformationFlows()
--			->collect(ev| ev.event)->collect(s| s->split('[+]'))->flatten()->asSet() in
--	let abstractEvents:Set(String) = events->select(s | s->isAbstractEvent()) in
--	if(abstractEvents->size()>0) then abstractEvents else events endif;
 	

helper context String def:isAbstractEvent():Boolean=
	'ABCDEFGHIJKLMNOPQRSTUVWXYZ'->indexOf(self->substring(1,1))>=0;
   
helper context SpMetamodel!Generalization def:getOutputData():Set(String)=
	let od:String=
		self.generalizes->getSpaceInformationFlows()->collect(ev| ev.event->split('[+]')->select(s|not s->isAbstractEvent()))
			->union(self.parent->getSpaceInformationFlows()->collect(ev| ev.event->split('[+]')->select(s|not s->isAbstractEvent())))
				->flatten()->asSet()->select(ev| ev->size()>0)				
--					->select(s|not s->isAbstractEvent())					
						->iterate(s; answer:String=''| s + '+' + answer) in
	(Set{})->including(
--		'Hola'
		od->substring(1,od->size()-1)
	);

helper context SpMetamodel!Space def: getSpaceInformationFlows():Set(TupleType(entity:String, event:String))=
	thisModule->getSpaceInformationFlows()
		->select(e | e.space=self.name)
			->collect(e | Tuple{entity=e.entity, event=e.event});

helper def: getSpaceInformationFlows(): Set(TupleType(entity:String, event:String, space:String)) =
	let events:Set(TupleType(entity:String, event:String, space:String))=
	thisModule->getEvents()
		->select(t | t.space->toSpace()->isEntity())
			->collect(t |
				Tuple{entity=t.entity->toSocialInstance()->getParentRoles()->select(r|r->isRoot())->any(x | true).name,
					event = t.event,
					space = t.space
				}
			)in
	let entities:Set(String)= events->collect(t|t.entity)->asSet() in
	let spaces:Set(String)= events->collect(t|t.space)->asSet() in
	entities
	->collect(e | 
		spaces->collect(s | 
			Tuple{entity=e, space=s, event= 
			let evs:String = 
				events->select(ev | ev.entity=e and ev.space=s)->asSet()
					->iterate(ev; answer:String='' | answer + ev.event+'+') in
					if(evs->size()>0) then evs->substring(1, evs->size()-1) else '' endif
			}
		)
	)->flatten()->select(ev| ev.event->size()>0);
	
	
helper def: getSpaceExpressionElements():Sequence(String)=	
	TaMetamodel!PreCondition.allInstances()
		->collect(pre | pre.spaceExpression)
			->select(s | not s->oclIsUndefined())
				->collect(s | s->split('[(),*+]'))->flatten()
					->collect(s | s->trim())
						->select(s | s->size()>0);

helper def:turnExpressionElementsIntoEvents(elements:Sequence(String)):Set(TupleType(entity:String, event:String, space:String))=
	if(elements->size()=0) then Set{}
	else thisModule->turnExpressionElementsIntoEvents(elements->subSequence(4,elements->size()))->including(Tuple{entity=elements->at(1), event=elements->at(2), space=elements->at(3)})endif;

helper def: getEvents():Set(TupleType(entity:String, event:String, space:String)) =
	thisModule->turnExpressionElementsIntoEvents(thisModule->getSpaceExpressionElements())
		->select(t | t.space->toSpace()->isEntity())
			->collect(t |
				Tuple{entity=t.entity->toSocialInstance()->getParentRoles()->any(x | true).name,
					event = t.event,
					space = t.space
				}
			);

helper def:getSystemInformationFlow(): IFMetamdoel!SystemInformaitonFlow = 
	thisModule.resolveTemp(thisModule->getSociety(), 'systemIF');

helper context String def:isPhysicalSpace():Boolean=
	SpMetamodel!PhysicalSpace.allInstances()->collect(s | s.name)->includes(self);

helper context String def:isVirtualSpace():Boolean=
	SpMetamodel!VirtualSpace.allInstances()->collect(s | s.name)->includes(self);


helper context String def: toSpace():SpMetamodel!Space=
	if(self->isPhysicalSpace()) then SpMetamodel!PhysicalSpace.allInstances()->any(s | s.name=self)
	else SpMetamodel!VirtualSpace.allInstances()->any(s | s.name=self) endif;

helper context SpMetamodel!Space def: isEntity(): Boolean =
	let preconditionSpaceElements: Set(String) =
		TaMetamodel!PreCondition.allInstances()
			->select(pre |	pre.ongoing.target->oclIsTypeOf(TaMetamodel!SimpleTask))
				->collect(pre | pre.spaceExpression)
					->select(s | not s->oclIsUndefined())
						->collect(s | s->split('[(),+]'))->flatten()
							->collect(s | s->trim()) in
		preconditionSpaceElements->includes(self.name) 
--			and (preconditionSpaceElements->excludesAll(self->getGeneralizedPhysicalSpaces()->collect(phs | phs.name->trim()))
--				or  self->oclIsTypeOf(SpMetamodel!PhysicalSpace))
		;


helper context SpMetamodel!VirtualSpace def: getGeneralizedPhysicalSpaces(): Set(SpModel!PhysicalSpace) =
	self.generalizes->select(s | s.parent=self)
		->collect(g | g.generalizes->getGeneralizedPhysicalSpaces())->flatten();
	
helper context SpMetamodel!PhysicalSpace def: getGeneralizedPhysicalSpaces(): Set(SpModel!PhysicalSpace) =
	Set{self};

helper context TaMetamodel!SystemTask def: getOutputVaraibles():Set(String)=
	let targetEntity:SoMetamodel!Role = self->getInformationFlow().target->getEntities()->any(x|true) in		
		self.ongoing.target->getVaraibles()
			->select(v | v.socialInstance.name=targetEntity.name)
				->collect(v|v.varaible);

helper context TaMetamodel!SystemTask def: getInputVaraibles():Set(String)=
	let sourceEntity:SoMetamodel!Role = self->getInformationFlow().source->getEntities()->any(x|true) in
		self.ongoing.target->getVaraibles()
			->select(v | v.socialInstance.name=sourceEntity.name)
				->collect(v|v.varaible);

helper context TaMetamodel!Condition def:getVaraibles():Set(TupleType(entity:SoModel!Role, varaible:String))=
	if(self.dataExpression->oclIsUndefined())then Set{} else
	self.dataExpression->getDataDefinitionFromDataExpression() endif;

helper context String def:getDataDefinitionFromDataExpression():Set(TupleType(entity:SoModel!Role, varaible:String))=
	self->trim()->split('[,]')->collect(d | 
		let pair:Sequence(String) = d.split('[()]') in
			Tuple{socialInstance=pair->at(1)->toSocialInstance()->getEntities()->any(x|true), varaible=pair->at(2)}
	);

helper context TaMetamodel!SystemTask def: getInformationFlow(): TupleType(source:SoMetamodel!Role, target:SoMetamodel!Role)=
	let socialInstanceNames: Sequence(String) =	self.incoming.source.socialExpression->split('[,+()]')->collect(si|si->trim()) in
	Tuple{
		source = socialInstanceNames->at(1)->toSocialInstance()->getEntities()->any(x|true),	
		target = socialInstanceNames->at(2)->toSocialInstance()->getEntities()->any(x|true)
	};

helper context TaMetamodel!SystemTask def: isPointToPointInformationFlow():Boolean=
	let socialInstanceNames:Sequence(String) =	self.incoming.source.socialExpression->split('[,+()]')->collect(si|si->trim()) in
		if (socialInstanceNames->size()=2) then socialInstanceNames->at(2)->isIndividualInstance() else false endif;

helper context TaMetamodel!SystemTask def: isBroadcastInformationFlow():Boolean=
	let socialInstanceNames:Sequence(String) =	self.incoming.source.socialExpression->split('[,+()]')->collect(si|si->trim()) in
		if (socialInstanceNames->size()=2) then socialInstanceNames->at(2)->isRole() else false endif;		
		
helper def: getSociety():SoMetamodel!Society=SoMetamodel!Society->allInstances()->any(x|true);

helper context SoMetamodel!Role def: getRoleVaraibleDefinition():String =	 
	let children:Set(SoMetamodel!Role) = self->getChildRoleHierarchy() in
	if(children->size()=1)then 'String' else 
		let answer:String = children->iterate(r; answer:String =''| answer + '+ '+r.name) in answer.substring(2, answer->size()) 
	endif;
		
helper context SoMetamodel!Role def: getChildRoleHierarchy():Set(SoMetamodel!Role) =
	self.parent->collect(g | g.source.getChildRoleHierarchy())->flatten()->including(self);

helper context TaMetamodel!SystemTask def: getEntity():SoMetaModel!Role =
	self->getInvolvedEntities()->any(x | true);
	
helper context TaMetamodel!SystemTask def: getInvolvedEntities():Set(SoMetaModel!Role) =
	self.incoming.source.socialExpression->getSocialExpressionEntities();

helper context String def: getSocialExpressionEntities():Set(SoMetamodel!Role)=
	self->split('[,+()]')->collect(s | s.trim().getRoleListFromSocialInstance())->flatten()
		->collect(e| e.getEntities())->flatten()->asSet();

helper context TaMetamodel!SystemTask def:getRoles():Set(SoMetamodel!Role)=
	self.incoming.source.socialExpression->split('[,+()]')
		->collect(s | s.trim())
			->collect(s |if(s->isIndividualInstance())then s->toIndividualInstance()->toRoles()else Set{s->toRole()}endif)
				->flatten();


helper context String def: isIndividualInstance():Boolean=	
	SoMetamodel!IndividualInstance.allInstances()->collect(i|i.name)->includes(self);			
		
helper context SoMetamodel!IndividualInstance def: toRoles():Set(SoMetamodel!Role)=
	self.realizes->collect(r | r.target);
			
helper context String def: getRoleListFromSocialInstance():Set(SoMetamodel!Role) = 
	if(self.isRole()) then Set{self.toRole()} else self.toIndividualInstance().realizes->collect(r|r.target) endif;

helper context String def: toRole():SoMetamodel!Role =
	SoMetamodel!Role.allInstances()->any(r | self = r.name);

helper context String def: toIndividualInstance():SoMetamodel!IndividualInstance =
	SoMetamodel!IndividualInstance.allInstances()->any(i | self = i.name);

helper context String def: toSocialInstance():SoMetamodel!SocialInstance =
	if(self->isRole()) then self->toRole() else self->toIndividualInstance() endif;

helper context String def: isRole():Boolean =
	SoMetamodel!Role.allInstances()->iterate(r; ans : Boolean = false| ans or self = r.name);

helper context SoMetamodel!SocialInstance def: getEntities():Set(SoMetamodel!Role)=
	self->getParentRoles()->select(r| r.isRoot());

helper context SoMetamodel!IndividualInstance def: getParentRoles():Set(SoMetamodel!Role)=
	self.realizes->collect(real | real.target.getParentRoles())->flatten();	

helper context SoMetamodel!Role def: getParentRoles():Set(SoMetamodel!Role)=
	if(self.children->size()>0)then
		self.children->collect(spec | spec.target->getParentRoles())->flatten()->including(self)
	else Set{self} endif->asSet();

helper context SoMetamodel!Role def: isRoot():Boolean = self.children->size()=0;



--leaves

--	self.parent->collect(g | g.source)->union(
--		self.parent->collect(g | g.source.getChildRoleHierarchy())->flatten()
--	);


-- More rules

--rule SocietyToSystemInfomrationFlowReferenceSpace{	
--	from 
--			society : SoMetamodel!Society
--	to
--			systemReferenceSpace : RSMetamodel!SystemInformationFlowReferenceSpace
--			(name <- society.name, entityReferences<-society.roles, referentialSpaces<-referenceSpace),
--			referenceSpace : RSMetamodel!ReferentialSpace
--			(name<-'The System', system<-society),
--			systemInformationFlow : IFMetamodel!SystemInformaitonFlow
--			(name <- society.name, entities<-society.roles),
--			systemContext : ECMetamodel!SystemContext
--			(name <- society.name, entities<-society.roles)
--	do{		
--		systemReferenceSpace.id <- thisModule.rsCounter;
--		thisModule.rsCounter <- thisModule.rsCounter + 1;
--		referenceSpace.id <- thisModule.rsCounter;
--		thisModule.rsCounter <- thisModule.rsCounter + 1;
--		systemInformationFlow.id <- thisModule.ifCounter;
--		thisModule.ifCounter <- thisModule.ifCounter + 1;
----		systemContext.id <- thisModule.ecCounter;
----		thisModule.ecCounter <- thisModule.ecCounter + 1;	
--	}
--}
--
--rule MemoryRule{	
--	from 
--			contextAwareSystem : TaMetamodel!ContextAwareSystem 			
--	to
--			roleMemories: distinct ECMetamodel!HolderMemory
--			foreach(role in thisModule->getSocialMemories())
--				(name <- 'roleMemory', entityContext<-thisModule.resolveTemp(role.getRole(), 'entityContext')),
--			
--			taskMemories: distinct ECMetamodel!StackMemory			
--			foreach(role in thisModule->getTaskMemories())
--				(name <- 'taskMemory', entityContext<-thisModule.resolveTemp(role.getRole(), 'entityContext')),
--				
--			spaceMemories: distinct ECMetamodel!StackMemory			
--			foreach(role in thisModule->getSpaceMemories())
--				(name <- 'spaceMemory', entityContext<-thisModule.resolveTemp(role.getRole(), 'entityContext')),
--
--			logicMemories: distinct ECMetamodel!LogicMemory			
--			foreach(role in thisModule->getLogicMemories())
--				(name <- 'logicMemory', entityContext<-thisModule.resolveTemp(role.getRole(), 'entityContext')),
--
--			dataMemories: distinct ECMetamodel!DictionaryMemory			
--			foreach(role in thisModule->getDataMemories())
--				(name <- 'dataMemory', entityContext<-thisModule.resolveTemp(role.getRole(), 'entityContext'))				
--				
--	do{
--		for(rm in roleMemories){
--			rm.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;
--		}
--		for(tm in taskMemories){
--			tm.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;
--		}
--		for(sm in spaceMemories){
--			sm.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;
--		}
--		for(lm in logicMemories){
--			lm.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;
--		}	
--		
--		for(dm in dataMemories){
--			dm.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;
--		}
--	}
--}
--
--rule RoleToContextAwareEntityReference{	
--	from 
--			role : SoMetamodel!Role (role.children.size()=0)			
--	to
--			contextAwareEntity : RSMetamodel!ContextAwareEntityReference
--			(name <- role.name, system <- role.society, entity<-role.name),
--			space2Entity : RSMetamodel!SpaceToEntityReferenceDependency
--			(system <- role.society, child<-role, parent <- thisModule.resolveTemp(role.society, 'referenceSpace'), cardinality<-999),
--			entity : IFMetamodel!ContextAwareEntity
--			(name <- role.name, system <- thisModule.resolveTemp(role.society, 'systemInformationFlow')),
--			entityContext : ECMetamodel!EntityContext
--			(entity <- role.name, system <- thisModule.resolveTemp(role.society, 'systemContext')),
----			roleMemory : ECMetamodel!HolderMemory
----			(name <- 'roleMemory', entityContext<-entityContext),--thisModule.resolveTemp(role, 'entityContext')),
----			spaceMemory : ECMetamodel!StackMemory
----			(name <- 'spaceMemory', entityContext<-thisModule.resolveTemp(role, 'entityContext')),
----			taskMemory : ECMetamodel!StackMemory
----			(name <- 'taskMemory', entityContext<-thisModule.resolveTemp(role, 'entityContext')),
----			logicMemory : ECMetamodel!LogicMemory
----			(name <- 'logicMemory', entityContext<-thisModule.resolveTemp(role, 'entityContext')),
----			dataMemory : ECMetamodel!DictionaryMemory
----			(name <- 'dataMemory', entityContext<-thisModule.resolveTemp(role, 'entityContext')),
--
--			initMemory: ECMetamodel!TimeMemory
--				(name <- 'initMemory', entityContext<-thisModule.resolveTemp(role, 'entityContext')),
--
--			initSituation:ECMetamodel!ContextSituation
--				(name<-'init-'+role.name, entityContext<-thisModule.resolveTemp(role, 'entityContext')),				
--				
--			initCondition:ECMetamodel!MemoryContextCondition
--				(expression <- 'off', situation<-thisModule.resolveTemp(role, 'initSituation'), contextMemory<-thisModule.resolveTemp(role, 'initMemory')),
--
--			endInitAction: ECMetamodel!ContextAction
--				(expression <- '(on,0)', situation<-thisModule.resolveTemp(role, 'initSituation'), memory<-thisModule.resolveTemp(role, 'initMemory')),
--				
--			initAction: distinct ECMetamodel!ContextAction
--				foreach(s in role->getInitialActions())	
--					(expression <-s.action, situation<-thisModule.resolveTemp(role, 'initSituation'), 												
--					memory<- if (s.memory='social') then 
--					thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true) , 'roleMemories')
--						->any(m | m.entityContext.entity=entityContext.entity)
--				else
--					if (s.memory='task') then
--						thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true) , 'taskMemories')
--							->any(m | m.entityContext.entity=entityContext.entity)
--					else
--						if (s.memory='space') then
--							thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true), 'spaceMemories')
--								->any(m | m.entityContext.entity=entityContext.entity)
--						else
--							if (s.memory='logic') then							
--								thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true), 'logicMemories')
--									->any(m | m.entityContext.entity=entityContext.entity)
--							else
--								thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true), 'dataMemories')
--									->any(m | m.entityContext.entity=entityContext.entity)								
--							endif
--						endif
--					endif
--				endif
--			),						
--	
--			variableDefinitions: distinct ECMetamodel!VariableDataDefinition 
--				foreach (e in role->getVaraiblesInSystem())
--					(name<-e, entityContext<-thisModule.resolveTemp(role, 'entityContext'), definition<-'String'),					
--
--			variableSpaceDefinitions: distinct ECMetamodel!VariableDataDefinition 
--				foreach (e in role->getSpaceVariables())
--					(name<-e.name, 
--					entityContext<-thisModule.resolveTemp(role, 'entityContext'), 
--					definition<-e.definition),					
--					
--			variableSocialDefinitions: distinct ECMetamodel!VariableDataDefinition 
--				foreach (e in role->getSocialVariables())
--					(name<-e.name, 
--					entityContext<-thisModule.resolveTemp(role, 'entityContext'), 
--					definition<-e.definition),
--					
--			eventSituations: distinct ECMetamodel!ContextSituation
--			foreach(s in role->getEventSituations())
--					(name<-s,
----						memoryConditions<-eventConditions,
----						actions<-actions,
--						entityContext<-thisModule.resolveTemp(role, 'entityContext')						
--					),
--					
--			eventConditions: distinct ECMetamodel!MemoryContextCondition
--			foreach(s in role->getEventConditions()->asSequence())
--				(expression <- s.condition, 
----					situation<-thisModule.resolveTemp(role, 'eventSituations'), 
--					contextMemory<-	if (s.memory='social') then 
--						thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(sy|true) , 'roleMemories')
--							->any(m | m.entityContext.entity=entityContext.entity)
--					else
--						if (s.memory='task') then
--							thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(sy|true) , 'taskMemories')
--								->any(m | m.entityContext.entity=entityContext.entity)
--						else
--							if (s.memory='space') then							
--								thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(sy|true), 'spaceMemories')
--									->any(m | m.entityContext.entity=entityContext.entity)
--							else
--								if (s.memory='logic') then
--									thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(sy|true), 'logicMemories')
--										->any(m | m.entityContext.entity=entityContext.entity)
--								else
--									thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(sy|true), 'dataMemories')
--										->any(m | m.entityContext.entity=entityContext.entity)						
--								endif 
--							endif
--						endif
--					endif,					
--					situation<-eventSituations->any(s2 | s2.name=s.name and s2.entityContext = 
--						thisModule.resolveTemp(role, 'entityContext'))
--				)
--	do{
--	    contextAwareEntity.id <- thisModule.rsCounter;
--		thisModule.rsCounter <- thisModule.rsCounter + 1;
--		space2Entity.id <- thisModule.rsCounter;
--		thisModule.rsCounter <- thisModule.rsCounter + 1;	
--		entity.id <- thisModule.ifCounter;
--		thisModule.ifCounter <- thisModule.ifCounter + 1;
--		entityContext.id <- thisModule.ecCounter;
--		thisModule.ecCounter <- thisModule.ecCounter + 1;
----		roleMemory.id <- thisModule.ecCounter;
----		thisModule.ecCounter <- thisModule.ecCounter + 1;		
----		spaceMemory.id <- thisModule.ecCounter;
----		thisModule.ecCounter <- thisModule.ecCounter + 1;		
----		taskMemory.id <- thisModule.ecCounter;
----		thisModule.ecCounter <- thisModule.ecCounter + 1;		
----		logicMemory.id <- thisModule.ecCounter;
----		thisModule.ecCounter <- thisModule.ecCounter + 1;
----		dataMemory.id <- thisModule.ecCounter;
----		thisModule.ecCounter <- thisModule.ecCounter + 1;
--		initMemory.id <- thisModule.ecCounter;
--		thisModule.ecCounter <- thisModule.ecCounter + 1;
--		initSituation.id <- thisModule.ecCounter;
--		thisModule.ecCounter <- thisModule.ecCounter + 1;
--		initCondition.id <- thisModule.ecCounter;		
--		thisModule.ecCounter <- thisModule.ecCounter + 1;
----		initAction.id <- thisModule.ecCounter;		
--		thisModule.ecCounter <- thisModule.ecCounter + 1;		
--		for(var in variableDefinitions){
--			var.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;			
--		}
--		for(var in variableSocialDefinitions){
--			var.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;			
--		}
--		for(var in variableSpaceDefinitions){
--			var.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;			
--		}		
--		for(evs in eventSituations){
--			evs.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;
--		}
--		for(evs in eventConditions){
--			evs.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;
--		}
--		
--		initMemory.id <- thisModule.ecCounter;		
--		thisModule.ecCounter <- thisModule.ecCounter + 1;
--		initSituation.id <- thisModule.ecCounter;		
--		thisModule.ecCounter <- thisModule.ecCounter + 1;
--		initCondition.id <- thisModule.ecCounter;		
--		thisModule.ecCounter <- thisModule.ecCounter + 1;
--		endInitAction.id <- thisModule.ecCounter;		
--		thisModule.ecCounter <- thisModule.ecCounter + 1;
--		for(a in initAction){
--			a.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;
--		}
--
--		
--	}
--}
--
--rule TaskToInformationFlow{	
--	from 
--		task : TaMetamodel!SimpleTask			
--	to
--		broadcastInformationFlow : distinct IFMetamodel!BroadcastInformationFlow
--			foreach(flow in task->getBroadcastInformationFlows())
--				(name <- (flow.fromRole+'_to_'+flow.toRole+'-'+ task.name), 
--						data<-broadcastOutputData, 				
--				system<-thisModule.resolveTemp(SoMetamodel!Society.allInstances()->first(), 'systemInformationFlow')),		
--				
--		broadcastOutputData : distinct IFMetamodel!OutputData
--			foreach(v in task.getBroadcastInformationFlowVariables())
--				(definition<-v),
--				
--		entity2BroadcastEdge: distinct IFMetamodel!EntityToBroadcastInformationFlowEdge
--		foreach(flow in task->getBroadcastInformationFlows())
--				(target<-broadcastInformationFlow, 
--					source<-thisModule.resolveTemp(flow.fromRole.getRole(),'entity'),
--					system<-thisModule.resolveTemp(SoMetamodel!Society.allInstances()->first(), 'systemInformationFlow')
--				),		
--
--		broadcast2EntityEdge: distinct IFMetamodel!BroadcastInformationFlowToEntityEdge
--		foreach(flow in task->getBroadcastInformationFlows())
--				(source<-broadcastInformationFlow, 
--					target<-thisModule.resolveTemp(flow.toRole.getRole(),'entity'),
--					system<-thisModule.resolveTemp(SoMetamodel!Society.allInstances()->first(), 'systemInformationFlow')),
--					
--		pointToPointInformationFlow : distinct IFMetamodel!PointToPointInformationFlow
--			foreach(flow in task->getPointToPointInformationFlows())
--				(name <- (flow.fromRole+'_to_'+flow.toRole+'-'+task.name), outputData<-pointToPointOutputData, 				
--				system<-thisModule.resolveTemp(SoMetamodel!Society.allInstances()->first(), 'systemInformationFlow')),	
--		
--		pointToPointOutputData : distinct IFMetamodel!OutputData
--			foreach(v in task.getPointToPointInformationFlowVariables())
--				(definition<-v),
--				
--		entity2PointToPointEdge: distinct IFMetamodel!EntityToPointToPointInformationFlowEdge
--		foreach(flow in task->getPointToPointInformationFlows())
--				(target<-pointToPointInformationFlow, 
--					source<-thisModule.resolveTemp(flow.fromRole.getRole(),'entity'),
--					system<-thisModule.resolveTemp(SoMetamodel!Society.allInstances()->first(), 'systemInformationFlow')),		
--		
--		pointToPoint2EntityEdge: distinct IFMetamodel!PointToPointInformationFlowToEntityEdge
--		foreach(flow in task->getPointToPointInformationFlows())
--				(source<-pointToPointInformationFlow, 
--					target<-thisModule.resolveTemp(flow.toRole.getRole(),'entity'),
--					system<-thisModule.resolveTemp(SoMetamodel!Society.allInstances()->first(), 'systemInformationFlow')),
--					
--		situations: distinct ECMetamodel!ContextSituation
--		foreach(s in task->getSituations())
--				(name<-task.name,
----					memoryConditions<-conditions,
----					actions<-actions,
--					entityContext<-thisModule.resolveTemp(s.entity.getRole(), 'entityContext')
--				),
--	
--				
--		sensing: distinct ECMetamodel!SensingContextCondition
--		foreach(sc in task->getSensingConditions())
--			(informationflow<-sc.informationflow,
--				situation<-situations->any(s | s.name=task.name and s.entityContext = 
--				thisModule.resolveTemp(sc.entity.getRole(), 'entityContext'))
--				),
--				
--		conditions: distinct ECMetamodel!MemoryContextCondition
--		foreach(c in task->getMemoryConditions())			 
--			(expression <- c.condition,
--				contextMemory<-	if (c.memory='social') then 
--					thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true) , 'roleMemories')
--						->any(m | m.entityContext.entity=c.entity)
--				else
--					if (c.memory='task') then
--						thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true) , 'taskMemories')
--							->any(m | m.entityContext.entity=c.entity)
--					else
--						if (c.memory='space') then
--							thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true), 'spaceMemories')
--								->any(m | m.entityContext.entity=c.entity)
--						else
--							if (c.memory='logic') then
--								thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true), 'logicMemories')
--									->any(m | m.entityContext.entity=c.entity)
--							else
--								thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true), 'dataMemories')
--									->any(m | m.entityContext.entity=c.entity)								
--							endif 
--						endif
--					endif
--				endif,
--			situation<-situations->any(s | s.name=task.name and s.entityContext = 
--				thisModule.resolveTemp(c.entity.getRole(), 'entityContext'))
--				),
--		
--		actions: distinct ECMetamodel!ContextAction
--		foreach(c in task->getMemoryActions())			 
--			(expression <- c.action,
--				memory<-	if (c.memory='social') then 
--					thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true) , 'roleMemories')
--						->any(m | m.entityContext.entity=c.entity)
--				else
--					if (c.memory='task') then
--						thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true) , 'taskMemories')
--							->any(m | m.entityContext.entity=c.entity)
--					else
--						if (c.memory='space') then
--							thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true), 'spaceMemories')
--								->any(m | m.entityContext.entity=c.entity)
--						else
--							if (c.memory='logic') then							
--								thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true), 'logicMemories')
--									->any(m | m.entityContext.entity=c.entity)
--							else
--								thisModule.resolveTemp(TaMetamodel!ContextAwareSystem.allInstances()->any(s|true), 'dataMemories')
--									->any(m | m.entityContext.entity=c.entity)								
--							endif
--						endif
--					endif
--				endif,
--			situation<-situations->any(s | s.name=task.name and s.entityContext = 
--				thisModule.resolveTemp(c.entity.getRole(), 'entityContext')))--,			
--				
--	do{
--		for (f in broadcastInformationFlow){
--			f.id <- thisModule.ifCounter;
--			thisModule.ifCounter <- thisModule.ifCounter + 1;
--		}
--		for (f in pointToPointInformationFlow){
--			f.id <- thisModule.ifCounter;
--			thisModule.ifCounter <- thisModule.ifCounter + 1;
--		}
--		for (s in situations){
--			s.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;
--		}
--		for (c in conditions){
--			c.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;
--		}		
--		for (c in sensing){
--			c.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;
--		}	
--		for (a in actions){
--			a.id <- thisModule.ecCounter;
--			thisModule.ecCounter <- thisModule.ecCounter + 1;
--		}	
--	}
--}
--
----rule Events{
----from 
----	task : TaMetamodel!SkipTask			
----to
----	eventSituations: distinct ECMetamodel!ContextSituation
----	foreach(s in task->getEventSituations())
----			(name<-'anEvent',
------				memoryConditions<-conditions,
------				actions<-actions,
----				entityContext<-thisModule.resolveTemp(s.getRole(), 'entityContext')
----			)
----	do{
----		for (e in eventSituations){
----				e.id <- thisModule.ecCounter;
----				thisModule.ecCounter <- thisModule.ecCounter + 1;
----			}
----	}
----}